"use strict";

exports.__esModule = true;
exports.dnd_adhoc_metric = exports.dnd_adhoc_metrics = exports.dnd_adhoc_filters = exports.dndEntity = exports.dndSeries = exports.dndColumnsControl = exports.dndGroupByControl = void 0;

var _core = require("@superset-ui/core");

var _utils = require("../utils");

var _constants = require("../constants");

/* eslint-disable camelcase */

/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
const dndGroupByControl = {
  type: 'DndColumnSelect',
  label: (0, _core.t)('Group by'),
  default: [],
  description: (0, _core.t)('One or many columns to group by'),

  mapStateToProps(state, {
    includeTime
  }) {
    const newState = {};

    if (state.datasource) {
      const options = state.datasource.columns.filter(c => c.groupby);

      if (includeTime) {
        options.unshift(_constants.TIME_COLUMN_OPTION);
      }

      newState.options = Object.fromEntries(options.map(option => [option.column_name, option]));
    }

    return newState;
  }

};
exports.dndGroupByControl = dndGroupByControl;
const dndColumnsControl = { ...dndGroupByControl,
  label: (0, _core.t)('Columns'),
  description: (0, _core.t)('One or many columns to pivot as columns')
};
exports.dndColumnsControl = dndColumnsControl;
const dndSeries = { ...dndGroupByControl,
  label: (0, _core.t)('Series'),
  multi: false,
  default: null,
  description: (0, _core.t)('Defines the grouping of entities. ' + 'Each series is shown as a specific color on the chart and ' + 'has a legend toggle')
};
exports.dndSeries = dndSeries;
const dndEntity = { ...dndGroupByControl,
  label: (0, _core.t)('Entity'),
  default: null,
  multi: false,
  validators: [_core.validateNonEmpty],
  description: (0, _core.t)('This defines the element to be plotted on the chart')
};
exports.dndEntity = dndEntity;
const dnd_adhoc_filters = {
  type: 'DndFilterSelect',
  label: (0, _core.t)('Filters'),
  default: null,
  description: '',
  mapStateToProps: ({
    datasource,
    form_data
  }) => ({
    columns: (datasource == null ? void 0 : datasource.columns.filter(c => c.filterable)) || [],
    savedMetrics: (datasource == null ? void 0 : datasource.metrics) || [],
    // current active adhoc metrics
    selectedMetrics: form_data.metrics || (form_data.metric ? [form_data.metric] : []),
    datasource
  }),
  provideFormDataToProps: true
};
exports.dnd_adhoc_filters = dnd_adhoc_filters;
const dnd_adhoc_metrics = {
  type: 'DndMetricSelect',
  multi: true,
  label: (0, _core.t)('Metrics'),
  validators: [_core.validateNonEmpty],
  default: c => {
    const metric = (0, _utils.mainMetric)(c.savedMetrics);
    return metric ? [metric] : null;
  },
  mapStateToProps: ({
    datasource
  }) => ({
    columns: datasource ? datasource.columns : [],
    savedMetrics: datasource ? datasource.metrics : [],
    datasourceType: datasource == null ? void 0 : datasource.type
  }),
  description: (0, _core.t)('One or many metrics to display')
};
exports.dnd_adhoc_metrics = dnd_adhoc_metrics;
const dnd_adhoc_metric = { ...dnd_adhoc_metrics,
  multi: false,
  label: (0, _core.t)('Metric'),
  description: (0, _core.t)('Metric'),
  default: c => (0, _utils.mainMetric)(c.savedMetrics)
};
exports.dnd_adhoc_metric = dnd_adhoc_metric;