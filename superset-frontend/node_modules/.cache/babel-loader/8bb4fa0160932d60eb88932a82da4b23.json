{"ast":null,"code":"import _Array$isArray from \"@babel/runtime-corejs3/core-js-stable/array/is-array\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { CUSTOM_OPERATORS } from 'src/explore/constants';\nimport { getSimpleSQLExpression } from 'src/explore/exploreUtils';\n\nexport const EXPRESSION_TYPES = {\n  SIMPLE: 'SIMPLE',\n  SQL: 'SQL' };\n\n\nexport const CLAUSES = {\n  HAVING: 'HAVING',\n  WHERE: 'WHERE' };\n\n\nconst OPERATORS_TO_SQL = {\n  '==': '=',\n  '!=': '<>',\n  '>': '>',\n  '<': '<',\n  '>=': '>=',\n  '<=': '<=',\n  IN: 'IN',\n  'NOT IN': 'NOT IN',\n  LIKE: 'LIKE',\n  REGEX: 'REGEX',\n  'IS NOT NULL': 'IS NOT NULL',\n  'IS NULL': 'IS NULL',\n  'LATEST PARTITION': ({ datasource }) =>\n  `= '{{ presto.latest_partition('${datasource.schema}.${datasource.datasource_name}') }}'` };\n\n\nfunction translateToSql(adhocMetric, { useSimple } = {}) {\n  if (adhocMetric.expressionType === EXPRESSION_TYPES.SIMPLE || useSimple) {\n    const { subject, comparator } = adhocMetric;\n    const operator =\n    adhocMetric.operator && CUSTOM_OPERATORS.has(adhocMetric.operator) ?\n    OPERATORS_TO_SQL[adhocMetric.operator](adhocMetric) :\n    OPERATORS_TO_SQL[adhocMetric.operator];\n    return getSimpleSQLExpression(subject, operator, comparator);\n  }\n  if (adhocMetric.expressionType === EXPRESSION_TYPES.SQL) {\n    return adhocMetric.sqlExpression;\n  }\n  return '';\n}\n\nexport default class AdhocFilter {\n  constructor(adhocFilter) {\n    this.expressionType = adhocFilter.expressionType || EXPRESSION_TYPES.SIMPLE;\n    if (this.expressionType === EXPRESSION_TYPES.SIMPLE) {var _adhocFilter$operator;\n      this.subject = adhocFilter.subject;\n      this.operator = (_adhocFilter$operator = adhocFilter.operator) == null ? void 0 : _adhocFilter$operator.toUpperCase();\n      this.comparator = adhocFilter.comparator;\n      this.clause = adhocFilter.clause || CLAUSES.WHERE;\n      this.sqlExpression = null;\n    } else if (this.expressionType === EXPRESSION_TYPES.SQL) {\n      this.sqlExpression =\n      typeof adhocFilter.sqlExpression === 'string' ?\n      adhocFilter.sqlExpression :\n      translateToSql(adhocFilter, { useSimple: true });\n      this.clause = adhocFilter.clause;\n      if (adhocFilter.operator && CUSTOM_OPERATORS.has(adhocFilter.operator)) {\n        this.subject = adhocFilter.subject;\n        this.operator = adhocFilter.operator;\n      } else {\n        this.subject = null;\n        this.operator = null;\n      }\n      this.comparator = null;\n    }\n    this.isExtra = !!adhocFilter.isExtra;\n    this.isNew = !!adhocFilter.isNew;\n\n    this.filterOptionName =\n    adhocFilter.filterOptionName ||\n    `filter_${Math.random().\n    toString(36).\n    substring(2, 15)}_${Math.random().toString(36).substring(2, 15)}`;\n  }\n\n  duplicateWith(nextFields) {\n    return new AdhocFilter({\n      ...this,\n      // all duplicated fields are not new (i.e. will not open popup automatically)\n      isNew: false,\n      ...nextFields });\n\n  }\n\n  equals(adhocFilter) {\n    return (\n      adhocFilter.expressionType === this.expressionType &&\n      adhocFilter.sqlExpression === this.sqlExpression &&\n      adhocFilter.operator === this.operator &&\n      adhocFilter.comparator === this.comparator &&\n      adhocFilter.subject === this.subject);\n\n  }\n\n  isValid() {\n    if (this.expressionType === EXPRESSION_TYPES.SIMPLE) {\n      if (this.operator === 'IS NOT NULL' || this.operator === 'IS NULL') {\n        return !!(this.operator && this.subject);\n      }\n\n      if (this.operator && this.subject && this.clause) {\n        if (_Array$isArray(this.comparator)) {\n          if (this.comparator.length > 0) {\n            // A non-empty array of values ('IN' or 'NOT IN' clauses)\n            return true;\n          }\n        } else if (this.comparator !== null) {\n          // A value has been selected or typed\n          return true;\n        }\n      }\n    } else if (this.expressionType === EXPRESSION_TYPES.SQL) {\n      return !!(this.sqlExpression && this.clause);\n    }\n    return false;\n  }\n\n  getDefaultLabel() {\n    const label = this.translateToSql();\n    return label.length < 43 ? label : `${label.substring(0, 40)}...`;\n  }\n\n  translateToSql() {\n    return translateToSql(this);\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(EXPRESSION_TYPES, \"EXPRESSION_TYPES\", \"/app/superset-frontend/src/explore/components/controls/FilterControl/AdhocFilter.js\");reactHotLoader.register(CLAUSES, \"CLAUSES\", \"/app/superset-frontend/src/explore/components/controls/FilterControl/AdhocFilter.js\");reactHotLoader.register(OPERATORS_TO_SQL, \"OPERATORS_TO_SQL\", \"/app/superset-frontend/src/explore/components/controls/FilterControl/AdhocFilter.js\");reactHotLoader.register(translateToSql, \"translateToSql\", \"/app/superset-frontend/src/explore/components/controls/FilterControl/AdhocFilter.js\");reactHotLoader.register(AdhocFilter, \"AdhocFilter\", \"/app/superset-frontend/src/explore/components/controls/FilterControl/AdhocFilter.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/app/superset-frontend/src/explore/components/controls/FilterControl/AdhocFilter.js"],"names":["CUSTOM_OPERATORS","getSimpleSQLExpression","EXPRESSION_TYPES","SIMPLE","SQL","CLAUSES","HAVING","WHERE","OPERATORS_TO_SQL","IN","LIKE","REGEX","datasource","schema","datasource_name","translateToSql","adhocMetric","useSimple","expressionType","subject","comparator","operator","has","sqlExpression","AdhocFilter","constructor","adhocFilter","toUpperCase","clause","isExtra","isNew","filterOptionName","Math","random","toString","substring","duplicateWith","nextFields","equals","isValid","length","getDefaultLabel","label"],"mappings":"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","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { CUSTOM_OPERATORS } from 'src/explore/constants';\nimport { getSimpleSQLExpression } from 'src/explore/exploreUtils';\n\nexport const EXPRESSION_TYPES = {\n  SIMPLE: 'SIMPLE',\n  SQL: 'SQL',\n};\n\nexport const CLAUSES = {\n  HAVING: 'HAVING',\n  WHERE: 'WHERE',\n};\n\nconst OPERATORS_TO_SQL = {\n  '==': '=',\n  '!=': '<>',\n  '>': '>',\n  '<': '<',\n  '>=': '>=',\n  '<=': '<=',\n  IN: 'IN',\n  'NOT IN': 'NOT IN',\n  LIKE: 'LIKE',\n  REGEX: 'REGEX',\n  'IS NOT NULL': 'IS NOT NULL',\n  'IS NULL': 'IS NULL',\n  'LATEST PARTITION': ({ datasource }) =>\n    `= '{{ presto.latest_partition('${datasource.schema}.${datasource.datasource_name}') }}'`,\n};\n\nfunction translateToSql(adhocMetric, { useSimple } = {}) {\n  if (adhocMetric.expressionType === EXPRESSION_TYPES.SIMPLE || useSimple) {\n    const { subject, comparator } = adhocMetric;\n    const operator =\n      adhocMetric.operator && CUSTOM_OPERATORS.has(adhocMetric.operator)\n        ? OPERATORS_TO_SQL[adhocMetric.operator](adhocMetric)\n        : OPERATORS_TO_SQL[adhocMetric.operator];\n    return getSimpleSQLExpression(subject, operator, comparator);\n  }\n  if (adhocMetric.expressionType === EXPRESSION_TYPES.SQL) {\n    return adhocMetric.sqlExpression;\n  }\n  return '';\n}\n\nexport default class AdhocFilter {\n  constructor(adhocFilter) {\n    this.expressionType = adhocFilter.expressionType || EXPRESSION_TYPES.SIMPLE;\n    if (this.expressionType === EXPRESSION_TYPES.SIMPLE) {\n      this.subject = adhocFilter.subject;\n      this.operator = adhocFilter.operator?.toUpperCase();\n      this.comparator = adhocFilter.comparator;\n      this.clause = adhocFilter.clause || CLAUSES.WHERE;\n      this.sqlExpression = null;\n    } else if (this.expressionType === EXPRESSION_TYPES.SQL) {\n      this.sqlExpression =\n        typeof adhocFilter.sqlExpression === 'string'\n          ? adhocFilter.sqlExpression\n          : translateToSql(adhocFilter, { useSimple: true });\n      this.clause = adhocFilter.clause;\n      if (adhocFilter.operator && CUSTOM_OPERATORS.has(adhocFilter.operator)) {\n        this.subject = adhocFilter.subject;\n        this.operator = adhocFilter.operator;\n      } else {\n        this.subject = null;\n        this.operator = null;\n      }\n      this.comparator = null;\n    }\n    this.isExtra = !!adhocFilter.isExtra;\n    this.isNew = !!adhocFilter.isNew;\n\n    this.filterOptionName =\n      adhocFilter.filterOptionName ||\n      `filter_${Math.random()\n        .toString(36)\n        .substring(2, 15)}_${Math.random().toString(36).substring(2, 15)}`;\n  }\n\n  duplicateWith(nextFields) {\n    return new AdhocFilter({\n      ...this,\n      // all duplicated fields are not new (i.e. will not open popup automatically)\n      isNew: false,\n      ...nextFields,\n    });\n  }\n\n  equals(adhocFilter) {\n    return (\n      adhocFilter.expressionType === this.expressionType &&\n      adhocFilter.sqlExpression === this.sqlExpression &&\n      adhocFilter.operator === this.operator &&\n      adhocFilter.comparator === this.comparator &&\n      adhocFilter.subject === this.subject\n    );\n  }\n\n  isValid() {\n    if (this.expressionType === EXPRESSION_TYPES.SIMPLE) {\n      if (this.operator === 'IS NOT NULL' || this.operator === 'IS NULL') {\n        return !!(this.operator && this.subject);\n      }\n\n      if (this.operator && this.subject && this.clause) {\n        if (Array.isArray(this.comparator)) {\n          if (this.comparator.length > 0) {\n            // A non-empty array of values ('IN' or 'NOT IN' clauses)\n            return true;\n          }\n        } else if (this.comparator !== null) {\n          // A value has been selected or typed\n          return true;\n        }\n      }\n    } else if (this.expressionType === EXPRESSION_TYPES.SQL) {\n      return !!(this.sqlExpression && this.clause);\n    }\n    return false;\n  }\n\n  getDefaultLabel() {\n    const label = this.translateToSql();\n    return label.length < 43 ? label : `${label.substring(0, 40)}...`;\n  }\n\n  translateToSql() {\n    return translateToSql(this);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}