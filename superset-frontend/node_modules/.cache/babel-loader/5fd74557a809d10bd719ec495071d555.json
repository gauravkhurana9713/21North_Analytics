{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";import _findInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/find\";import _someInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/some\";import _sortInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/sort\";import _concatInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/concat\";import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";import _Object$keys from \"@babel/runtime-corejs3/core-js-stable/object/keys\";import _filterInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/filter\";import _mapInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/map\";import _reduceInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/reduce\";import _Array$isArray from \"@babel/runtime-corejs3/core-js-stable/array/is-array\";import _Object$values from \"@babel/runtime-corejs3/core-js-stable/object/values\";import _Set from \"@babel/runtime-corejs3/core-js-stable/set\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { TIME_FILTER_MAP } from 'src/explore/constants';\nimport { getChartIdsInFilterScope } from 'src/dashboard/util/activeDashboardFilters';\nimport { DataMaskType } from 'src/dataMask/types';\nimport { getTreeCheckedItems } from '../nativeFilters/FiltersConfigModal/FiltersConfigForm/FilterScope/utils';\nexport var IndicatorStatus;\n(function (IndicatorStatus) {\n  IndicatorStatus[\"Unset\"] = \"UNSET\";\n  IndicatorStatus[\"Applied\"] = \"APPLIED\";\n  IndicatorStatus[\"Incompatible\"] = \"INCOMPATIBLE\";\n  IndicatorStatus[\"CrossFilterApplied\"] = \"CROSS_FILTER_APPLIED\";\n})(IndicatorStatus || (IndicatorStatus = {}));\nconst TIME_GRANULARITY_FIELDS = new _Set(_Object$values(TIME_FILTER_MAP));\nconst selectIndicatorValue = (columnKey, filter, datasource) => {\n  const values = filter.columns[columnKey];\n  const arrValues = _Array$isArray(values) ? values : [values];\n  if (values == null ||\n  filter.isDateFilter && values === 'No filter' ||\n  arrValues.length === 0) {\n    return [];\n  }\n  if (filter.isDateFilter && TIME_GRANULARITY_FIELDS.has(columnKey)) {var _context;\n    const timeGranularityMap = _reduceInstanceProperty(_context = (columnKey === TIME_FILTER_MAP.time_grain_sqla ?\n    datasource.time_grain_sqla :\n    datasource.granularity) || []).call(_context, (map, [key, value]) => ({\n      ...map,\n      [key]: value }),\n    {});\n    return _mapInstanceProperty(arrValues).call(arrValues, value => timeGranularityMap[value] || value);\n  }\n  return arrValues;\n};\nconst selectIndicatorsForChartFromFilter = (chartId, filter, filterDataSource, appliedColumns, rejectedColumns) => {var _context2, _context3;\n  // filters can be applied (if the filter is compatible with the datasource)\n  // or rejected (if the filter is incompatible)\n  // or the status can be unknown (if the filter has calculated parameters that we can't analyze)\n  const getStatus = (column, filter) => {\n    if (appliedColumns.has(column) && filter.columns[column])\n    return IndicatorStatus.Applied;\n    if (rejectedColumns.has(column))\n    return IndicatorStatus.Incompatible;\n    return IndicatorStatus.Unset;\n  };\n  return _mapInstanceProperty(_context2 = _filterInstanceProperty(_context3 = _Object$keys(filter.columns)).call(_context3,\n  column => {var _context4;return _includesInstanceProperty(_context4 = getChartIdsInFilterScope({\n      filterScope: filter.scopes[column] })).call(_context4,\n    chartId);})).call(_context2,\n  column => ({\n    column,\n    name: filter.labels[column] || column,\n    value: selectIndicatorValue(column, filter, filterDataSource),\n    status: getStatus(column, filter),\n    path: filter.directPathToFilter }));\n\n};\nconst getAppliedColumns = chart => {var _context5, _chart$queriesRespons, _chart$queriesRespons2;return new _Set(_mapInstanceProperty(_context5 = (chart == null ? void 0 : (_chart$queriesRespons = chart.queriesResponse) == null ? void 0 : (_chart$queriesRespons2 = _chart$queriesRespons[0]) == null ? void 0 : _chart$queriesRespons2.applied_filters) || []).call(_context5, filter => filter.column));};\nconst getRejectedColumns = chart => {var _context6, _chart$queriesRespons3, _chart$queriesRespons4;return new _Set(_mapInstanceProperty(_context6 = (chart == null ? void 0 : (_chart$queriesRespons3 = chart.queriesResponse) == null ? void 0 : (_chart$queriesRespons4 = _chart$queriesRespons3[0]) == null ? void 0 : _chart$queriesRespons4.rejected_filters) || []).call(_context6, filter => filter.column));};\n// inspects redux state to find what the filter indicators should be shown for a given chart\nexport const selectIndicatorsForChart = (chartId, filters, datasources, charts) => {var _context7, _context8;\n  const chart = charts[chartId];\n  // no indicators if chart is loading\n  if (chart.chartStatus === 'loading')\n  return [];\n  // for now we only need to know which columns are compatible/incompatible,\n  // so grab the columns from the applied/rejected filters\n  const appliedColumns = getAppliedColumns(chart);\n  const rejectedColumns = getRejectedColumns(chart);\n  const indicators = _reduceInstanceProperty(_context7 = _filterInstanceProperty(_context8 = _Object$values(filters)).call(_context8,\n  filter => filter.chartId !== chartId)).call(_context7,\n  (acc, filter) => _concatInstanceProperty(acc).call(acc, selectIndicatorsForChartFromFilter(chartId, filter, datasources[filter.datasourceId] || {}, appliedColumns, rejectedColumns)), []);\n  _sortInstanceProperty(indicators).call(indicators, (a, b) => a.name.localeCompare(b.name));\n  return indicators;\n};\nexport const selectNativeIndicatorsForChart = (nativeFilters, dataMask, chartId, charts, dashboardLayout, chartConfiguration = {}) => {var _context9, _context11;\n  const chart = charts[chartId];\n  const appliedColumns = getAppliedColumns(chart);\n  const rejectedColumns = getRejectedColumns(chart);\n  const getStatus = ({ value, isAffectedByScope, column, type = DataMaskType.NativeFilters }) => {\n    // a filter is only considered unset if it's value is null\n    const hasValue = value !== null;\n    if (!isAffectedByScope) {\n      return IndicatorStatus.Unset;\n    }\n    if (type === DataMaskType.CrossFilters && hasValue) {\n      return IndicatorStatus.CrossFilterApplied;\n    }\n    if (!column && hasValue) {\n      // Filter without datasource\n      return IndicatorStatus.Applied;\n    }\n    if (column && rejectedColumns.has(column))\n    return IndicatorStatus.Incompatible;\n    if (column && appliedColumns.has(column) && hasValue) {\n      return IndicatorStatus.Applied;\n    }\n    return IndicatorStatus.Unset;\n  };\n  const nativeFilterIndicators = _mapInstanceProperty(_context9 = _Object$values(nativeFilters.filters)).call(_context9, nativeFilter => {var _context10, _nativeFilter$targets, _nativeFilter$targets2, _dataMask$nativeFilte, _dataMaskNativeFilter, _dataMaskNativeFilter2;\n    const isAffectedByScope = _someInstanceProperty(_context10 = getTreeCheckedItems(nativeFilter.scope, dashboardLayout)).call(_context10, layoutItem => {var _dashboardLayout$layo, _dashboardLayout$layo2;return ((_dashboardLayout$layo = dashboardLayout[layoutItem]) == null ? void 0 : (_dashboardLayout$layo2 = _dashboardLayout$layo.meta) == null ? void 0 : _dashboardLayout$layo2.chartId) === chartId;});\n    const column = (_nativeFilter$targets = nativeFilter.targets[0]) == null ? void 0 : (_nativeFilter$targets2 = _nativeFilter$targets.column) == null ? void 0 : _nativeFilter$targets2.name;\n    const dataMaskNativeFilters = (_dataMask$nativeFilte = dataMask.nativeFilters) == null ? void 0 : _dataMask$nativeFilte[nativeFilter.id];\n    let value = (_dataMaskNativeFilter = dataMaskNativeFilters == null ? void 0 : (_dataMaskNativeFilter2 = dataMaskNativeFilters.currentState) == null ? void 0 : _dataMaskNativeFilter2.value) != null ? _dataMaskNativeFilter : null;\n    if (!_Array$isArray(value) && value !== null) {\n      value = [value];\n    }\n    return {\n      column,\n      name: nativeFilter.name,\n      path: [nativeFilter.id],\n      status: getStatus({ value, isAffectedByScope, column }),\n      value };\n\n  });\n  const crossFilterIndicators = _mapInstanceProperty(_context11 = _Object$values(chartConfiguration)).call(_context11, chartConfig => {var _chartConfig$crossFil, _context12, _dataMask$crossFilter, _dataMaskCrossFilters, _dataMaskCrossFilters2, _Object$values$find, _Object$values$find$m, _context13;\n    const scope = chartConfig == null ? void 0 : (_chartConfig$crossFil = chartConfig.crossFilters) == null ? void 0 : _chartConfig$crossFil.scope;\n    const isAffectedByScope = _someInstanceProperty(_context12 = getTreeCheckedItems(scope, dashboardLayout)).call(_context12, layoutItem => {var _dashboardLayout$layo3, _dashboardLayout$layo4;return ((_dashboardLayout$layo3 = dashboardLayout[layoutItem]) == null ? void 0 : (_dashboardLayout$layo4 = _dashboardLayout$layo3.meta) == null ? void 0 : _dashboardLayout$layo4.chartId) === chartId;});\n    const dataMaskCrossFilters = (_dataMask$crossFilter = dataMask.crossFilters) == null ? void 0 : _dataMask$crossFilter[chartConfig.id];\n    let value = (_dataMaskCrossFilters = dataMaskCrossFilters == null ? void 0 : (_dataMaskCrossFilters2 = dataMaskCrossFilters.currentState) == null ? void 0 : _dataMaskCrossFilters2.value) != null ? _dataMaskCrossFilters : null;\n    if (!_Array$isArray(value) && value !== null) {\n      value = [value];\n    }\n    return {\n      name: (_Object$values$find = _findInstanceProperty(_context13 = _Object$values(dashboardLayout)).call(_context13, layoutItem => {var _layoutItem$meta;return (layoutItem == null ? void 0 : (_layoutItem$meta = layoutItem.meta) == null ? void 0 : _layoutItem$meta.chartId) === chartConfig.id;})) == null ? void 0 : (_Object$values$find$m = _Object$values$find.meta) == null ? void 0 : _Object$values$find$m.sliceName,\n      path: [`${chartConfig.id}`],\n      status: getStatus({\n        value,\n        isAffectedByScope,\n        type: DataMaskType.CrossFilters }),\n\n      value };\n\n  });\n  return _concatInstanceProperty(crossFilterIndicators).call(crossFilterIndicators, nativeFilterIndicators);\n};;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(IndicatorStatus, \"IndicatorStatus\", \"/app/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");reactHotLoader.register(TIME_GRANULARITY_FIELDS, \"TIME_GRANULARITY_FIELDS\", \"/app/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");reactHotLoader.register(selectIndicatorValue, \"selectIndicatorValue\", \"/app/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");reactHotLoader.register(selectIndicatorsForChartFromFilter, \"selectIndicatorsForChartFromFilter\", \"/app/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");reactHotLoader.register(getAppliedColumns, \"getAppliedColumns\", \"/app/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");reactHotLoader.register(getRejectedColumns, \"getRejectedColumns\", \"/app/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");reactHotLoader.register(selectIndicatorsForChart, \"selectIndicatorsForChart\", \"/app/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");reactHotLoader.register(selectNativeIndicatorsForChart, \"selectNativeIndicatorsForChart\", \"/app/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/app/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { TIME_FILTER_MAP } from 'src/explore/constants';\nimport { getChartIdsInFilterScope } from 'src/dashboard/util/activeDashboardFilters';\nimport {\n  ChartConfiguration,\n  NativeFiltersState,\n} from 'src/dashboard/reducers/types';\nimport { DataMaskStateWithId, DataMaskType } from 'src/dataMask/types';\nimport { Layout } from '../../types';\nimport { getTreeCheckedItems } from '../nativeFilters/FiltersConfigModal/FiltersConfigForm/FilterScope/utils';\n\nexport enum IndicatorStatus {\n  Unset = 'UNSET',\n  Applied = 'APPLIED',\n  Incompatible = 'INCOMPATIBLE',\n  CrossFilterApplied = 'CROSS_FILTER_APPLIED',\n}\n\nconst TIME_GRANULARITY_FIELDS = new Set(Object.values(TIME_FILTER_MAP));\n\n// As of 2020-09-28, the DatasourceMeta type in superset-ui is incorrect.\n// Should patch it here until the DatasourceMeta type is updated.\ntype Datasource = {\n  time_grain_sqla?: [string, string][];\n  granularity?: [string, string][];\n};\n\ntype Filter = {\n  chartId: number;\n  columns: { [key: string]: string | string[] };\n  scopes: { [key: string]: any };\n  labels: { [key: string]: string };\n  isDateFilter: boolean;\n  directPathToFilter: string[];\n  datasourceId: string;\n};\n\nconst selectIndicatorValue = (\n  columnKey: string,\n  filter: Filter,\n  datasource: Datasource,\n): any => {\n  const values = filter.columns[columnKey];\n  const arrValues = Array.isArray(values) ? values : [values];\n\n  if (\n    values == null ||\n    (filter.isDateFilter && values === 'No filter') ||\n    arrValues.length === 0\n  ) {\n    return [];\n  }\n\n  if (filter.isDateFilter && TIME_GRANULARITY_FIELDS.has(columnKey)) {\n    const timeGranularityMap = (\n      (columnKey === TIME_FILTER_MAP.time_grain_sqla\n        ? datasource.time_grain_sqla\n        : datasource.granularity) || []\n    ).reduce(\n      (map, [key, value]) => ({\n        ...map,\n        [key]: value,\n      }),\n      {},\n    );\n\n    return arrValues.map(value => timeGranularityMap[value] || value);\n  }\n\n  return arrValues;\n};\n\nconst selectIndicatorsForChartFromFilter = (\n  chartId: number,\n  filter: Filter,\n  filterDataSource: Datasource,\n  appliedColumns: Set<string>,\n  rejectedColumns: Set<string>,\n): Indicator[] => {\n  // filters can be applied (if the filter is compatible with the datasource)\n  // or rejected (if the filter is incompatible)\n  // or the status can be unknown (if the filter has calculated parameters that we can't analyze)\n  const getStatus = (column: string, filter: Filter) => {\n    if (appliedColumns.has(column) && filter.columns[column])\n      return IndicatorStatus.Applied;\n    if (rejectedColumns.has(column)) return IndicatorStatus.Incompatible;\n    return IndicatorStatus.Unset;\n  };\n\n  return Object.keys(filter.columns)\n    .filter(column =>\n      getChartIdsInFilterScope({\n        filterScope: filter.scopes[column],\n      }).includes(chartId),\n    )\n    .map(column => ({\n      column,\n      name: filter.labels[column] || column,\n      value: selectIndicatorValue(column, filter, filterDataSource),\n      status: getStatus(column, filter),\n      path: filter.directPathToFilter,\n    }));\n};\n\nconst getAppliedColumns = (chart: any): Set<string> =>\n  new Set(\n    (chart?.queriesResponse?.[0]?.applied_filters || []).map(\n      (filter: any) => filter.column,\n    ),\n  );\n\nconst getRejectedColumns = (chart: any): Set<string> =>\n  new Set(\n    (chart?.queriesResponse?.[0]?.rejected_filters || []).map(\n      (filter: any) => filter.column,\n    ),\n  );\n\nexport type Indicator = {\n  column?: string;\n  name: string;\n  value?: any;\n  status?: IndicatorStatus;\n  path?: string[];\n};\n\n// inspects redux state to find what the filter indicators should be shown for a given chart\nexport const selectIndicatorsForChart = (\n  chartId: number,\n  filters: { [key: number]: Filter },\n  datasources: { [key: string]: Datasource },\n  charts: any,\n): Indicator[] => {\n  const chart = charts[chartId];\n  // no indicators if chart is loading\n  if (chart.chartStatus === 'loading') return [];\n\n  // for now we only need to know which columns are compatible/incompatible,\n  // so grab the columns from the applied/rejected filters\n  const appliedColumns = getAppliedColumns(chart);\n  const rejectedColumns = getRejectedColumns(chart);\n\n  const indicators = Object.values(filters)\n    .filter(filter => filter.chartId !== chartId)\n    .reduce(\n      (acc, filter) =>\n        acc.concat(\n          selectIndicatorsForChartFromFilter(\n            chartId,\n            filter,\n            datasources[filter.datasourceId] || {},\n            appliedColumns,\n            rejectedColumns,\n          ),\n        ),\n      [] as Indicator[],\n    );\n  indicators.sort((a, b) => a.name.localeCompare(b.name));\n  return indicators;\n};\n\nexport const selectNativeIndicatorsForChart = (\n  nativeFilters: NativeFiltersState,\n  dataMask: DataMaskStateWithId,\n  chartId: number,\n  charts: any,\n  dashboardLayout: Layout,\n  chartConfiguration: ChartConfiguration = {},\n): Indicator[] => {\n  const chart = charts[chartId];\n\n  const appliedColumns = getAppliedColumns(chart);\n  const rejectedColumns = getRejectedColumns(chart);\n\n  const getStatus = ({\n    value,\n    isAffectedByScope,\n    column,\n    type = DataMaskType.NativeFilters,\n  }: {\n    value: any;\n    isAffectedByScope: boolean;\n    column?: string;\n    type?: DataMaskType;\n  }): IndicatorStatus => {\n    // a filter is only considered unset if it's value is null\n    const hasValue = value !== null;\n    if (!isAffectedByScope) {\n      return IndicatorStatus.Unset;\n    }\n    if (type === DataMaskType.CrossFilters && hasValue) {\n      return IndicatorStatus.CrossFilterApplied;\n    }\n    if (!column && hasValue) {\n      // Filter without datasource\n      return IndicatorStatus.Applied;\n    }\n    if (column && rejectedColumns.has(column))\n      return IndicatorStatus.Incompatible;\n    if (column && appliedColumns.has(column) && hasValue) {\n      return IndicatorStatus.Applied;\n    }\n    return IndicatorStatus.Unset;\n  };\n\n  const nativeFilterIndicators = Object.values(nativeFilters.filters).map(\n    nativeFilter => {\n      const isAffectedByScope = getTreeCheckedItems(\n        nativeFilter.scope,\n        dashboardLayout,\n      ).some(\n        layoutItem => dashboardLayout[layoutItem]?.meta?.chartId === chartId,\n      );\n      const column = nativeFilter.targets[0]?.column?.name;\n      const dataMaskNativeFilters = dataMask.nativeFilters?.[nativeFilter.id];\n      let value = dataMaskNativeFilters?.currentState?.value ?? null;\n      if (!Array.isArray(value) && value !== null) {\n        value = [value];\n      }\n      return {\n        column,\n        name: nativeFilter.name,\n        path: [nativeFilter.id],\n        status: getStatus({ value, isAffectedByScope, column }),\n        value,\n      };\n    },\n  );\n\n  const crossFilterIndicators = Object.values(chartConfiguration).map(\n    chartConfig => {\n      const scope = chartConfig?.crossFilters?.scope;\n      const isAffectedByScope = getTreeCheckedItems(\n        scope,\n        dashboardLayout,\n      ).some(\n        layoutItem => dashboardLayout[layoutItem]?.meta?.chartId === chartId,\n      );\n\n      const dataMaskCrossFilters = dataMask.crossFilters?.[chartConfig.id];\n      let value = dataMaskCrossFilters?.currentState?.value ?? null;\n      if (!Array.isArray(value) && value !== null) {\n        value = [value];\n      }\n      return {\n        name: Object.values(dashboardLayout).find(\n          layoutItem => layoutItem?.meta?.chartId === chartConfig.id,\n        )?.meta?.sliceName as string,\n        path: [`${chartConfig.id}`],\n        status: getStatus({\n          value,\n          isAffectedByScope,\n          type: DataMaskType.CrossFilters,\n        }),\n        value,\n      };\n    },\n  );\n\n  return crossFilterIndicators.concat(nativeFilterIndicators);\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}