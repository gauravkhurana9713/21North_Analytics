{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";import _mapInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/map\";import _findInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/find\";import _someInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/some\";import _filterInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/filter\";import _forEachInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/for-each\";import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};import shortid from 'shortid';\nexport const REMOVAL_DELAY_SECS = 5;\nexport const validateForm = async (form, currentFilterId, filterConfigMap, filterIds, removedFilters, setCurrentFilterId) => {\n  const addValidationError = (filterId, field, error) => {\n    const fieldError = {\n      name: ['filters', filterId, field],\n      errors: [error] };\n\n    form.setFields([fieldError]);\n    // eslint-disable-next-line no-throw-literal\n    throw { errorFields: [fieldError] };\n  };\n  try {var _context;\n    const formValues = await form.validateFields();\n    const validateInstant = filterId => {var _filterConfigMap$filt;\n      const isInstant = formValues.filters[filterId] ?\n      formValues.filters[filterId].isInstant : (_filterConfigMap$filt =\n      filterConfigMap[filterId]) == null ? void 0 : _filterConfigMap$filt.isInstant;\n      if (!isInstant) {\n        addValidationError(filterId, 'isInstant', 'For parent filters changes must be applied instantly');\n      }\n    };\n    const validateCycles = (filterId, trace = []) => {var _formValues$filters$f, _filterConfigMap$filt2, _filterConfigMap$filt3;\n      if (_includesInstanceProperty(trace).call(trace, filterId)) {\n        addValidationError(filterId, 'parentFilter', 'Cannot create cyclic hierarchy');\n      }\n      const parentId = formValues.filters[filterId] ? (_formValues$filters$f =\n      formValues.filters[filterId].parentFilter) == null ? void 0 : _formValues$filters$f.value : (_filterConfigMap$filt2 =\n      filterConfigMap[filterId]) == null ? void 0 : (_filterConfigMap$filt3 = _filterConfigMap$filt2.cascadeParentIds) == null ? void 0 : _filterConfigMap$filt3[0];\n      if (parentId) {\n        validateInstant(parentId);\n        validateCycles(parentId, [...trace, filterId]);\n      }\n    };\n    _forEachInstanceProperty(_context = _filterInstanceProperty(filterIds).call(filterIds,\n    id => !removedFilters[id])).call(_context,\n    filterId => validateCycles(filterId));\n    return formValues;\n  }\n  catch (error) {\n    console.warn('Filter configuration failed:', error);\n    if (!error.errorFields || !error.errorFields.length)\n    return null; // not a validation error\n    const errorFields = error.errorFields;\n    // filter id is the second item in the field name\n    if (!_someInstanceProperty(errorFields).call(errorFields, field => field.name[1] === currentFilterId)) {\n      // switch to the first tab that had a validation error\n      const filterError = _findInstanceProperty(errorFields).call(errorFields, field => field.name[0] === 'filters');\n      if (filterError) {\n        setCurrentFilterId(filterError.name[1]);\n      }\n    }\n    return null;\n  }\n};\nexport const createHandleSave = (form, currentFilterId, filterConfigMap, filterIds, removedFilters, setCurrentFilterId, resetForm, saveForm) => async () => {var _context2;\n  const values = await validateForm(form, currentFilterId, filterConfigMap, filterIds, removedFilters, setCurrentFilterId);\n  if (values == null)\n  return;\n  const newFilterConfig = _mapInstanceProperty(_context2 = _filterInstanceProperty(filterIds).call(filterIds,\n  id => !removedFilters[id])).call(_context2,\n  id => {\n    // create a filter config object from the form inputs\n    const formInputs = values.filters[id];\n    // if user didn't open a filter, return the original config\n    if (!formInputs)\n    return filterConfigMap[id];\n    const target = {};\n    if (formInputs.dataset) {\n      target.datasetId = formInputs.dataset.value;\n    }\n    if (formInputs.dataset && formInputs.column) {\n      target.column = { name: formInputs.column };\n    }\n    return {\n      id,\n      controlValues: formInputs.controlValues,\n      name: formInputs.name,\n      filterType: formInputs.filterType,\n      // for now there will only ever be one target\n      targets: [target],\n      defaultValue: formInputs.defaultValue || null,\n      cascadeParentIds: formInputs.parentFilter ?\n      [formInputs.parentFilter.value] :\n      [],\n      scope: formInputs.scope,\n      isInstant: formInputs.isInstant };\n\n  });\n  await saveForm(newFilterConfig);\n  resetForm();\n};\nexport const createHandleTabEdit = (setRemovedFilters, setSaveAlertVisible, addFilter) => (filterId, action) => {\n  const completeFilterRemoval = filterId => {\n    // the filter state will actually stick around in the form,\n    // and the filterConfig/newFilterIds, but we use removedFilters\n    // to mark it as removed.\n    setRemovedFilters(removedFilters => ({\n      ...removedFilters,\n      [filterId]: { isPending: false } }));\n\n  };\n  if (action === 'remove') {\n    // first set up the timer to completely remove it\n    const timerId = window.setTimeout(() => completeFilterRemoval(filterId), REMOVAL_DELAY_SECS * 1000);\n    // mark the filter state as \"removal in progress\"\n    setRemovedFilters(removedFilters => ({\n      ...removedFilters,\n      [filterId]: { isPending: true, timerId } }));\n\n    setSaveAlertVisible(false);\n  } else\n  if (action === 'add') {\n    addFilter();\n  }\n};\nexport const generateFilterId = () => `NATIVE_FILTER-${shortid.generate()}`;\nexport const getFilterIds = config => _mapInstanceProperty(config).call(config, filter => filter.id);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(REMOVAL_DELAY_SECS, \"REMOVAL_DELAY_SECS\", \"/app/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/utils.ts\");reactHotLoader.register(validateForm, \"validateForm\", \"/app/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/utils.ts\");reactHotLoader.register(createHandleSave, \"createHandleSave\", \"/app/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/utils.ts\");reactHotLoader.register(createHandleTabEdit, \"createHandleTabEdit\", \"/app/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/utils.ts\");reactHotLoader.register(generateFilterId, \"generateFilterId\", \"/app/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/utils.ts\");reactHotLoader.register(getFilterIds, \"getFilterIds\", \"/app/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/utils.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/app/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/utils.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { FormInstance } from 'antd/lib/form';\nimport shortid from 'shortid';\nimport { FilterRemoval, NativeFiltersForm } from './types';\nimport { Filter, FilterConfiguration, Target } from '../types';\n\nexport const REMOVAL_DELAY_SECS = 5;\n\nexport const validateForm = async (\n  form: FormInstance<NativeFiltersForm>,\n  currentFilterId: string,\n  filterConfigMap: Record<string, Filter>,\n  filterIds: string[],\n  removedFilters: Record<string, FilterRemoval>,\n  setCurrentFilterId: Function,\n) => {\n  const addValidationError = (\n    filterId: string,\n    field: string,\n    error: string,\n  ) => {\n    const fieldError = {\n      name: ['filters', filterId, field],\n      errors: [error],\n    };\n    form.setFields([fieldError]);\n    // eslint-disable-next-line no-throw-literal\n    throw { errorFields: [fieldError] };\n  };\n\n  try {\n    const formValues = (await form.validateFields()) as NativeFiltersForm;\n\n    const validateInstant = (filterId: string) => {\n      const isInstant = formValues.filters[filterId]\n        ? formValues.filters[filterId].isInstant\n        : filterConfigMap[filterId]?.isInstant;\n      if (!isInstant) {\n        addValidationError(\n          filterId,\n          'isInstant',\n          'For parent filters changes must be applied instantly',\n        );\n      }\n    };\n\n    const validateCycles = (filterId: string, trace: string[] = []) => {\n      if (trace.includes(filterId)) {\n        addValidationError(\n          filterId,\n          'parentFilter',\n          'Cannot create cyclic hierarchy',\n        );\n      }\n      const parentId = formValues.filters[filterId]\n        ? formValues.filters[filterId].parentFilter?.value\n        : filterConfigMap[filterId]?.cascadeParentIds?.[0];\n      if (parentId) {\n        validateInstant(parentId);\n        validateCycles(parentId, [...trace, filterId]);\n      }\n    };\n\n    filterIds\n      .filter(id => !removedFilters[id])\n      .forEach(filterId => validateCycles(filterId));\n\n    return formValues;\n  } catch (error) {\n    console.warn('Filter configuration failed:', error);\n\n    if (!error.errorFields || !error.errorFields.length) return null; // not a validation error\n\n    // the name is in array format since the fields are nested\n    type ErrorFields = { name: ['filters', string, string] }[];\n    const errorFields = error.errorFields as ErrorFields;\n    // filter id is the second item in the field name\n    if (!errorFields.some(field => field.name[1] === currentFilterId)) {\n      // switch to the first tab that had a validation error\n      const filterError = errorFields.find(\n        field => field.name[0] === 'filters',\n      );\n      if (filterError) {\n        setCurrentFilterId(filterError.name[1]);\n      }\n    }\n    return null;\n  }\n};\n\nexport const createHandleSave = (\n  form: FormInstance<NativeFiltersForm>,\n  currentFilterId: string,\n  filterConfigMap: Record<string, Filter>,\n  filterIds: string[],\n  removedFilters: Record<string, FilterRemoval>,\n  setCurrentFilterId: Function,\n  resetForm: Function,\n  saveForm: Function,\n) => async () => {\n  const values: NativeFiltersForm | null = await validateForm(\n    form,\n    currentFilterId,\n    filterConfigMap,\n    filterIds,\n    removedFilters,\n    setCurrentFilterId,\n  );\n  if (values == null) return;\n\n  const newFilterConfig: FilterConfiguration = filterIds\n    .filter(id => !removedFilters[id])\n    .map(id => {\n      // create a filter config object from the form inputs\n      const formInputs = values.filters[id];\n      // if user didn't open a filter, return the original config\n      if (!formInputs) return filterConfigMap[id];\n      const target: Partial<Target> = {};\n      if (formInputs.dataset) {\n        target.datasetId = formInputs.dataset.value;\n      }\n      if (formInputs.dataset && formInputs.column) {\n        target.column = { name: formInputs.column };\n      }\n      return {\n        id,\n        controlValues: formInputs.controlValues,\n        name: formInputs.name,\n        filterType: formInputs.filterType,\n        // for now there will only ever be one target\n        targets: [target],\n        defaultValue: formInputs.defaultValue || null,\n        cascadeParentIds: formInputs.parentFilter\n          ? [formInputs.parentFilter.value]\n          : [],\n        scope: formInputs.scope,\n        isInstant: formInputs.isInstant,\n      };\n    });\n\n  await saveForm(newFilterConfig);\n  resetForm();\n};\n\nexport const createHandleTabEdit = (\n  setRemovedFilters: (\n    value:\n      | ((\n          prevState: Record<string, FilterRemoval>,\n        ) => Record<string, FilterRemoval>)\n      | Record<string, FilterRemoval>,\n  ) => void,\n  setSaveAlertVisible: Function,\n  addFilter: Function,\n) => (filterId: string, action: 'add' | 'remove') => {\n  const completeFilterRemoval = (filterId: string) => {\n    // the filter state will actually stick around in the form,\n    // and the filterConfig/newFilterIds, but we use removedFilters\n    // to mark it as removed.\n    setRemovedFilters(removedFilters => ({\n      ...removedFilters,\n      [filterId]: { isPending: false },\n    }));\n  };\n\n  if (action === 'remove') {\n    // first set up the timer to completely remove it\n    const timerId = window.setTimeout(\n      () => completeFilterRemoval(filterId),\n      REMOVAL_DELAY_SECS * 1000,\n    );\n    // mark the filter state as \"removal in progress\"\n    setRemovedFilters(removedFilters => ({\n      ...removedFilters,\n      [filterId]: { isPending: true, timerId },\n    }));\n    setSaveAlertVisible(false);\n  } else if (action === 'add') {\n    addFilter();\n  }\n};\n\nexport const generateFilterId = () => `NATIVE_FILTER-${shortid.generate()}`;\n\nexport const getFilterIds = (config: FilterConfiguration) =>\n  config.map(filter => filter.id);\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}