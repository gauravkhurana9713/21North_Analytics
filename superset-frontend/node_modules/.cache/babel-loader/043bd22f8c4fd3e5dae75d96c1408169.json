{"ast":null,"code":"import _Object$values from \"@babel/runtime-corejs3/core-js-stable/object/values\";import _forEachInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/for-each\";import _valuesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/values\";import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { CHART_TYPE } from './componentTypes';\nimport { DASHBOARD_ROOT_ID } from './constants';\n// Looking for affected chart scopes and values\nexport const findAffectedCharts = ({ child, layout, scope, activeFilters, filterId, extraFormData }) => {var _layout$child, _layout$child$meta, _context2;\n  const chartId = (_layout$child = layout[child]) == null ? void 0 : (_layout$child$meta = _layout$child.meta) == null ? void 0 : _layout$child$meta.chartId;\n  if (layout[child].type === CHART_TYPE) {var _context;\n    // Ignore excluded charts\n    if (_includesInstanceProperty(_context = scope.excluded).call(_context, chartId)) {\n      return;\n    }\n    if (!activeFilters[filterId]) {\n      // Small mutation but simplify logic\n      // eslint-disable-next-line no-param-reassign\n      activeFilters[filterId] = {\n        scope: [],\n        values: [] };\n\n    }\n    // Add not excluded chart scopes(to know what charts refresh) and values(refresh only if its value changed)\n    activeFilters[filterId].scope.push(chartId);\n    _valuesInstanceProperty(activeFilters[filterId]).push(extraFormData);\n    return;\n  }\n  // If child is not chart, recursive iterate over its children\n  _forEachInstanceProperty(_context2 = layout[child].children).call(_context2, child => findAffectedCharts({\n    child,\n    layout,\n    scope,\n    activeFilters,\n    filterId,\n    extraFormData }));\n\n};\nexport const getAllActiveFilters = ({ chartConfiguration, nativeFilters, dataMask, layout }) => {var _context3;\n  const activeFilters = {};\n  // Combine native filters with cross filters, because they have similar logic\n  _forEachInstanceProperty(_context3 = _Object$values({\n    ...dataMask.nativeFilters,\n    ...dataMask.crossFilters })).call(_context3,\n  ({ id: filterId, extraFormData }) => {var _ref, _nativeFilters$filter, _nativeFilters$filter2, _chartConfiguration$f, _chartConfiguration$f2, _context4;\n    const scope = (_ref = (_nativeFilters$filter = nativeFilters == null ? void 0 : (_nativeFilters$filter2 = nativeFilters[filterId]) == null ? void 0 : _nativeFilters$filter2.scope) != null ? _nativeFilters$filter :\n    chartConfiguration == null ? void 0 : (_chartConfiguration$f = chartConfiguration[filterId]) == null ? void 0 : (_chartConfiguration$f2 = _chartConfiguration$f.crossFilters) == null ? void 0 : _chartConfiguration$f2.scope) != null ? _ref : {\n      rootPath: [DASHBOARD_ROOT_ID],\n      excluded: [] };\n\n    // Iterate over all roots to find all affected charts\n    _forEachInstanceProperty(_context4 = scope.rootPath).call(_context4, layoutItemId => {var _context5;\n      _forEachInstanceProperty(_context5 = layout[layoutItemId].children).call(_context5, child => {\n        // Need exclude from affected charts, charts that located in scope `excluded`\n        findAffectedCharts({\n          child,\n          layout,\n          scope,\n          activeFilters,\n          filterId,\n          extraFormData });\n\n      });\n    });\n  });\n  return activeFilters;\n};;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(findAffectedCharts, \"findAffectedCharts\", \"/app/superset-frontend/src/dashboard/util/activeAllDashboardFilters.ts\");reactHotLoader.register(getAllActiveFilters, \"getAllActiveFilters\", \"/app/superset-frontend/src/dashboard/util/activeAllDashboardFilters.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/app/superset-frontend/src/dashboard/util/activeAllDashboardFilters.ts"],"names":[],"mappings":"opBAAA;;;;;;;;;;;;;;;;;AAiBG;AACH,SAAS,UAAT,QAA2B,kBAA3B;AAIA,SAAS,iBAAT,QAAkC,aAAlC;AAGA;AACA,OAAO,MAAM,kBAAkB,GAAG,CAAC,EACjC,KADiC,EAEjC,MAFiC,EAGjC,KAHiC,EAIjC,aAJiC,EAKjC,QALiC,EAMjC,aANiC,EAAD,KAc7B;AACH,QAAM,OAAO,oBAAG,MAAM,CAAC,KAAD,CAAT,2CAAG,cAAe,IAAlB,qBAAG,mBAAqB,OAArC;AACA,MAAI,MAAM,CAAC,KAAD,CAAN,CAAc,IAAd,KAAuB,UAA3B,EAAuC;AACrC;AACA,QAAI,qCAAA,KAAK,CAAC,QAAN,iBAAwB,OAAxB,CAAJ,EAAsC;AACpC;AACD;AACD,QAAI,CAAC,aAAa,CAAC,QAAD,CAAlB,EAA8B;AAC5B;AACA;AACA,MAAA,aAAa,CAAC,QAAD,CAAb,GAA0B;AACxB,QAAA,KAAK,EAAE,EADiB;AAExB,QAAA,MAAM,EAAE,EAFgB,EAA1B;;AAID;AACD;AACA,IAAA,aAAa,CAAC,QAAD,CAAb,CAAwB,KAAxB,CAA8B,IAA9B,CAAmC,OAAnC;AACA,4BAAA,aAAa,CAAC,QAAD,CAAb,EAA+B,IAA/B,CAAoC,aAApC;AACA;AACD;AACD;AACA,uCAAA,MAAM,CAAC,KAAD,CAAN,CAAc,QAAd,kBAAgC,KAAD,IAC7B,kBAAkB,CAAC;AACjB,IAAA,KADiB;AAEjB,IAAA,MAFiB;AAGjB,IAAA,KAHiB;AAIjB,IAAA,aAJiB;AAKjB,IAAA,QALiB;AAMjB,IAAA,aANiB,EAAD,CADpB;;AAUD,CA7CM;AA+CP,OAAO,MAAM,mBAAmB,GAAG,CAAC,EAClC,kBADkC,EAElC,aAFkC,EAGlC,QAHkC,EAIlC,MAJkC,EAAD,KAUf;AAClB,QAAM,aAAa,GAAG,EAAtB;AAEA;AACA,sDAAc;AACZ,OAAG,QAAQ,CAAC,aADA;AAEZ,OAAG,QAAQ,CAAC,YAFA,EAAd;AAGW,GAAC,EAAE,EAAE,EAAE,QAAN,EAAgB,aAAhB,EAAD,KAAoC;AAC7C,UAAM,KAAK,oCAAG,aAAH,8CAAG,aAAa,CAAG,QAAH,CAAhB,qBAAG,uBAA2B,KAA9B;AACT,IAAA,kBADS,6CACT,kBAAkB,CAAG,QAAH,CADT,+CACT,sBAAgC,YADvB,qBACT,uBAA8C,KADrC,mBAC8C;AACrD,MAAA,QAAQ,EAAE,CAAC,iBAAD,CAD2C;AAErD,MAAA,QAAQ,EAAE,EAF2C,EADzD;;AAKA;AACA,yCAAA,KAAK,CAAC,QAAN,kBAAuB,YAAY,IAAG;AACpC,2CAAA,MAAM,CAAC,YAAD,CAAN,CAAqB,QAArB,kBAAuC,KAAD,IAAkB;AACtD;AACA,QAAA,kBAAkB,CAAC;AACjB,UAAA,KADiB;AAEjB,UAAA,MAFiB;AAGjB,UAAA,KAHiB;AAIjB,UAAA,aAJiB;AAKjB,UAAA,QALiB;AAMjB,UAAA,aANiB,EAAD,CAAlB;;AAQD,OAVD;AAWD,KAZD;AAaD,GAvBD;AAwBA,SAAO,aAAP;AACD,CAvCM,C,iLA/CM,kB,0HA+CA,mB","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { CHART_TYPE } from './componentTypes';\nimport { Scope } from '../components/nativeFilters/types';\nimport { ActiveFilters, LayoutItem } from '../types';\nimport { ChartConfiguration, Filters } from '../reducers/types';\nimport { DASHBOARD_ROOT_ID } from './constants';\nimport { DataMaskStateWithId } from '../../dataMask/types';\n\n// Looking for affected chart scopes and values\nexport const findAffectedCharts = ({\n  child,\n  layout,\n  scope,\n  activeFilters,\n  filterId,\n  extraFormData,\n}: {\n  child: string;\n  layout: { [key: string]: LayoutItem };\n  scope: Scope;\n  activeFilters: ActiveFilters;\n  filterId: string;\n  extraFormData: any;\n}) => {\n  const chartId = layout[child]?.meta?.chartId;\n  if (layout[child].type === CHART_TYPE) {\n    // Ignore excluded charts\n    if (scope.excluded.includes(chartId)) {\n      return;\n    }\n    if (!activeFilters[filterId]) {\n      // Small mutation but simplify logic\n      // eslint-disable-next-line no-param-reassign\n      activeFilters[filterId] = {\n        scope: [],\n        values: [],\n      };\n    }\n    // Add not excluded chart scopes(to know what charts refresh) and values(refresh only if its value changed)\n    activeFilters[filterId].scope.push(chartId);\n    activeFilters[filterId].values.push(extraFormData);\n    return;\n  }\n  // If child is not chart, recursive iterate over its children\n  layout[child].children.forEach((child: string) =>\n    findAffectedCharts({\n      child,\n      layout,\n      scope,\n      activeFilters,\n      filterId,\n      extraFormData,\n    }),\n  );\n};\n\nexport const getAllActiveFilters = ({\n  chartConfiguration,\n  nativeFilters,\n  dataMask,\n  layout,\n}: {\n  chartConfiguration: ChartConfiguration;\n  dataMask: DataMaskStateWithId;\n  nativeFilters: Filters;\n  layout: { [key: string]: LayoutItem };\n}): ActiveFilters => {\n  const activeFilters = {};\n\n  // Combine native filters with cross filters, because they have similar logic\n  Object.values({\n    ...dataMask.nativeFilters,\n    ...dataMask.crossFilters,\n  }).forEach(({ id: filterId, extraFormData }) => {\n    const scope = nativeFilters?.[filterId]?.scope ??\n      chartConfiguration?.[filterId]?.crossFilters?.scope ?? {\n        rootPath: [DASHBOARD_ROOT_ID],\n        excluded: [],\n      };\n    // Iterate over all roots to find all affected charts\n    scope.rootPath.forEach(layoutItemId => {\n      layout[layoutItemId].children.forEach((child: string) => {\n        // Need exclude from affected charts, charts that located in scope `excluded`\n        findAffectedCharts({\n          child,\n          layout,\n          scope,\n          activeFilters,\n          filterId,\n          extraFormData,\n        });\n      });\n    });\n  });\n  return activeFilters;\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}