"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var ts = tslib_1.__importStar(require("typescript"));
var source_map_1 = require("source-map");
var convert = tslib_1.__importStar(require("convert-source-map"));
var path_1 = require("path");
var lodash_1 = require("lodash");
var find_root_1 = tslib_1.__importDefault(require("find-root"));
var hashString = require('@emotion/hash').default;
var hasDefaultExports = ['@emotion/styled'];
var libraries = ['@emotion/styled', 'emotion', '@emotion/core'];
var functions = ['css', 'keyframes', 'injectGlobal', 'merge'];
var defaultOptions = {
    sourcemap: true,
    autoLabel: true,
    labelFormat: '[local]',
    autoInject: true,
};
var getPackageRootPath = lodash_1.memoize(function (filename) { return find_root_1.default(filename); });
var hashArray = function (arr) { return hashString(arr.join('')); };
var createImportJSXAst = lodash_1.memoize(function (propertyName) {
    var importClause = ts.createImportClause(undefined, ts.createNamedImports([
        propertyName
            ? ts.createImportSpecifier(ts.createIdentifier('jsx'), ts.createIdentifier(propertyName))
            : ts.createImportSpecifier(undefined, ts.createIdentifier('jsx')),
    ]));
    var moduleSpecifier = ts.createStringLiteral('@emotion/core');
    return ts.createImportDeclaration(undefined, undefined, importClause, moduleSpecifier);
});
exports.createEmotionPlugin = function (options) {
    var notNullOptions = options
        ? tslib_1.__assign(tslib_1.__assign({}, defaultOptions), options) : tslib_1.__assign({}, defaultOptions);
    var transformer = function (context) {
        var importCalls = [];
        var compilerOptions = context.getCompilerOptions();
        var sourcemapGenerator;
        var emotionTargetClassNameCount = 0;
        var sourceFile;
        var inserted = false;
        var visitor = function (node) {
            if (ts.isSourceFile(node)) {
                inserted = false;
                return ts.visitEachChild(node, visitor, context);
            }
            if (ts.isImportDeclaration(node)) {
                importCalls = importCalls.concat(getImportCalls(node, compilerOptions));
                if (!inserted &&
                    notNullOptions.autoInject &&
                    node.moduleSpecifier.text === 'react') {
                    inserted = true;
                    return [createImportJSXAst(compilerOptions.jsxFactory), node];
                }
                return node;
            }
            if (notNullOptions.autoLabel || notNullOptions.sourcemap) {
                if (ts.isCallExpression(node)) {
                    var expression_1 = node.expression;
                    if (ts.isCallExpression(expression_1) ||
                        ts.isPropertyAccessExpression(expression_1) ||
                        ts.isIdentifier(expression_1)) {
                        var subExpression_1 = (ts.isIdentifier(expression_1)
                            ? node
                            : expression_1).expression;
                        var transformedNode_1 = node;
                        var updateCallFunction = function () { return transformedNode_1; };
                        if (ts.isPropertyAccessExpression(expression_1)) {
                            var info = importCalls.find(function (importInfo) {
                                return importInfo.name ===
                                    expression_1
                                        .expression.text;
                            });
                            if (info &&
                                (info.moduleName === '@emotion/styled' ||
                                    (notNullOptions.customStyledModuleName != undefined &&
                                        notNullOptions.customStyledModuleName === info.moduleName))) {
                                expression_1 = ts.createCall(expression_1.expression, [], [ts.createStringLiteral(expression_1.name.text)]);
                            }
                        }
                        var exp_1 = ts.isCallExpression(expression_1) ? expression_1 : null;
                        if (exp_1) {
                            updateCallFunction = function () {
                                if (exp_1.arguments.length === 1) {
                                    var filename = sourceFile.fileName;
                                    var moduleName = '';
                                    var rootPath = filename;
                                    try {
                                        rootPath = getPackageRootPath(filename);
                                        moduleName = require(rootPath + '/package.json').name;
                                    }
                                    catch (err) {
                                    }
                                    var finalPath = filename === rootPath
                                        ? 'root'
                                        : filename.slice(rootPath.length);
                                    var positionInFile = emotionTargetClassNameCount++;
                                    var stuffToHash = [moduleName];
                                    if (finalPath) {
                                        stuffToHash.push(path_1.normalize(finalPath));
                                    }
                                    else {
                                        stuffToHash.push(sourceFile.getText());
                                    }
                                    var stableClassName = "e" + hashArray(stuffToHash) + positionInFile;
                                    var updatedCall = ts.updateCall(exp_1, exp_1.expression, exp_1.typeArguments, exp_1.arguments.concat([
                                        ts.createObjectLiteral([
                                            ts.createPropertyAssignment(ts.createIdentifier('target'), ts.createStringLiteral(stableClassName)),
                                        ], true),
                                    ]));
                                    return ts.updateCall(transformedNode_1, updatedCall, transformedNode_1.typeArguments, transformedNode_1.arguments);
                                }
                                return transformedNode_1;
                            };
                        }
                        if (ts.isIdentifier(subExpression_1) ||
                            ts.isPropertyAccessExpression(subExpression_1)) {
                            var importedInfo = ts.isIdentifier(subExpression_1)
                                ? importCalls.find(function (imported) { return imported.name === subExpression_1.text; })
                                : importCalls.find(function (imported) {
                                    return imported.name ===
                                        subExpression_1.expression.text;
                                });
                            if (importedInfo) {
                                var propertyToAccess = importedInfo.type === 'namespaceImport'
                                    ? (expression_1.name ||
                                        subExpression_1.name).text
                                    : '';
                                var isEmotionCall = (importedInfo.type === 'namespaceImport' &&
                                    (propertyToAccess === 'default' ||
                                        functions.includes(propertyToAccess))) ||
                                    importedInfo.type !== 'namespaceImport';
                                if (isEmotionCall) {
                                    if (notNullOptions.autoLabel) {
                                        var rawPath = sourceFile.fileName;
                                        var localNameNode = node.parent
                                            .name;
                                        if (localNameNode && ts.isIdentifier(localNameNode)) {
                                            var local = localNameNode.text;
                                            var fileName = path_1.basename(rawPath, path_1.extname(rawPath));
                                            transformedNode_1 = ts.updateCall(transformedNode_1, transformedNode_1.expression, transformedNode_1.typeArguments, transformedNode_1.arguments.concat([
                                                ts.createStringLiteral("label:" + notNullOptions
                                                    .labelFormat.replace('[local]', local)
                                                    .replace('[filename]', fileName) + ";"),
                                            ]));
                                        }
                                    }
                                    if (notNullOptions.sourcemap &&
                                        process.env.NODE_ENV !== 'production') {
                                        var sourceFileNode = node.getSourceFile();
                                        var lineAndCharacter = ts.getLineAndCharacterOfPosition(sourceFileNode, node.pos);
                                        var sourceFileName = path_1.relative(process.cwd(), sourceFileNode.fileName);
                                        sourcemapGenerator.addMapping({
                                            generated: {
                                                line: 1,
                                                column: 0,
                                            },
                                            source: sourceFileName,
                                            original: {
                                                line: lineAndCharacter.line + 1,
                                                column: lineAndCharacter.character + 1,
                                            },
                                        });
                                        sourcemapGenerator.setSourceContent(sourceFileName, sourceFileNode.text);
                                        var comment = convert
                                            .fromObject(sourcemapGenerator)
                                            .toComment({ multiline: true });
                                        transformedNode_1 = ts.updateCall(transformedNode_1, transformedNode_1.expression, transformedNode_1.typeArguments, transformedNode_1.arguments.concat([
                                            ts.createStringLiteral(comment),
                                        ]));
                                    }
                                    transformedNode_1 = ts.addSyntheticLeadingComment(transformedNode_1, ts.SyntaxKind.MultiLineCommentTrivia, '#__PURE__');
                                    return updateCallFunction();
                                }
                            }
                        }
                    }
                }
            }
            return ts.visitEachChild(node, visitor, context);
        };
        return function (node) {
            sourceFile = node;
            sourcemapGenerator = new source_map_1.SourceMapGenerator({
                file: path_1.basename(node.fileName),
                sourceRoot: '',
            });
            var distNode = ts.visitNode(node, visitor);
            importCalls = [];
            return distNode;
        };
    };
    return transformer;
};
function getImportCalls(importDeclarationNode, compilerOptions) {
    var importCalls = [];
    var moduleName = importDeclarationNode.moduleSpecifier
        .text;
    if (!importDeclarationNode.importClause) {
        return importCalls;
    }
    var _a = importDeclarationNode.importClause, name = _a.name, namedBindings = _a.namedBindings;
    if (libraries.includes(moduleName)) {
        if (name) {
            if (moduleName === 'emotion' &&
                compilerOptions.allowSyntheticDefaultImports) {
                importCalls.push({
                    name: name.text,
                    type: 'namespaceImport',
                    moduleName: moduleName,
                });
            }
            else if (hasDefaultExports.includes(moduleName)) {
                importCalls.push({
                    name: name.text,
                    type: 'defaultImport',
                    moduleName: moduleName,
                });
            }
        }
        if (namedBindings) {
            if (ts.isNamedImports(namedBindings)) {
                namedBindings.forEachChild(function (node) {
                    if (hasDefaultExports.includes(moduleName) &&
                        node.propertyName &&
                        node.propertyName.text === 'default') {
                        importCalls.push({
                            name: node.name.text,
                            type: 'namedImport',
                            moduleName: moduleName,
                        });
                    }
                    if (node.propertyName &&
                        functions.includes(node.propertyName.text)) {
                        importCalls.push({
                            name: node.name.text,
                            type: 'namedImport',
                            moduleName: moduleName,
                        });
                    }
                    if (!node.propertyName &&
                        functions.includes(node.name.text)) {
                        importCalls.push({
                            name: node.name.text,
                            type: 'namedImport',
                            moduleName: moduleName,
                        });
                    }
                });
            }
            else {
                importCalls.push({
                    name: namedBindings.name.text,
                    type: 'namespaceImport',
                    moduleName: moduleName,
                });
            }
        }
    }
    return importCalls;
}
//# sourceMappingURL=index.js.map